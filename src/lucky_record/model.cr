require "db"
require "levenshtein"

class LuckyRecord::Model
  include LuckyRecord::Associations

  macro inherited
    FIELDS = [] of {name: Symbol, type: Object, nilable: Bool, autogenerated: Bool}
    ASSOCIATIONS = [] of {name: Symbol, foreign_key: Symbol}

    field id : Int32, autogenerated: true
    field created_at : Time, autogenerated: true
    field updated_at : Time, autogenerated: true
  end

  def_equals @id

  def to_param
    id.to_s
  end

  macro table(table_name)
    {{yield}}
    setup {{table_name}}
  end

  def delete
    LuckyRecord::Repo.run do |db|
      db.exec "DELETE FROM #{@@table_name} WHERE id = #{id}"
    end
  end

  macro setup(table_name)
    {% table_name = table_name.id %}
    setup_initialize
    setup_db_mapping
    setup_getters
    setup_base_query_class({{table_name}})
    setup_base_form_class({{table_name}})
    setup_table_name({{table_name}})
    setup_fields_method
    setup_correct_field_mappings_method
  end

  macro setup_table_name(table_name)
    @@table_name = :{{table_name}}
    TABLE_NAME = :{{table_name}}
  end

  macro setup_initialize
    def initialize(
        {% for field in FIELDS %}
          @{{field[:name]}},
        {% end %}
      )
    end
  end

  macro setup_db_mapping
    DB.mapping({
      {% for field in FIELDS %}
        {{field[:name]}}: {
          type: {{field[:type]}}::Lucky::ColumnType,
          nilable: {{field[:nilable]}},
        },
      {% end %}
    })
  end

  macro setup_base_query_class(table_name)
    LuckyRecord::BaseQueryTemplate.setup({{ @type }}, {{ FIELDS }}, {{ ASSOCIATIONS }}, {{ table_name }})
  end

  macro setup_base_form_class(table_name)
    LuckyRecord::BaseFormTemplate.setup({{ @type }}, {{ FIELDS }}, {{ table_name }})
  end

  macro setup_getters
    {% for field in FIELDS %}
      def {{field[:name]}}
        {{ field[:type] }}::Lucky.from_db! @{{field[:name]}}
      end
    {% end %}
  end

  macro field(type_declaration, autogenerated = false)
    {% if type_declaration.type.is_a?(Union) %}
      {% data_type = "#{type_declaration.type.types.first}".id %}
      {% nilable = true %}
    {% else %}
      {% data_type = "#{type_declaration.type}".id %}
      {% nilable = false %}
    {% end %}
    {% FIELDS << {name: type_declaration.var, type: data_type, nilable: nilable.id, autogenerated: autogenerated} %}
  end

  macro setup_fields_method
    def self.column_names : Array(Symbol)
      [
        {% for field in FIELDS %}
          :{{field[:name]}},
        {% end %}
      ]
    end
  end

  macro association(table_name, foreign_key = nil)
    {% ASSOCIATIONS << {name: table_name.id, foreign_key: foreign_key} %}
  end

  macro setup_correct_field_mappings_method
    def ensure_correct_field_mappings!
      ensure_existing_table!

      fields = [
        {% for field in FIELDS %}
          { name: :{{field[:name]}}, nilable: {{ field[:nilable] }}, type: {{ field[:type] }} },
        {% end %}
      ]
      ensure_fields_match_columns! fields
    end
  end

  def ensure_existing_table!
    table_names = LuckyRecord::Repo.tables_with_schema(excluding: "migrations")
    return if table_names.includes?(@@table_name.to_s)

    best_match = Levenshtein::Finder.find @@table_name.to_s, table_names, tolerance: 4
    message = "The table '#{@@table_name}' was not found."

    if best_match
      message += " Did you mean #{best_match}?"
    end

    raise message
  end

  def ensure_fields_match_columns!(fields)
    columns = LuckyRecord::Repo.table_columns(@@table_name)

    columns_map = Hash(String, Bool).new
    columns.each do |column|
      columns_map[column.name] = column.nilable
    end

    missing_columns = [] of String
    optional_field_errors = [] of String
    required_field_errors = [] of String

    fields.each do |field|
      unless columns_map.has_key? field[:name].to_s
        missing_columns << missing_field_error(columns, field)
        next
      end

      if !field[:nilable] && columns_map[field[:name].to_s]
        required_field_errors << required_field_error(field)
      elsif field[:nilable] && !columns_map[field[:name].to_s]
        optional_field_errors << optional_field_error(field)
      end
    end

    if missing_columns.empty? && optional_field_errors.empty? &&required_field_errors.empty?
      return
    end

    message = missing_columns + optional_field_errors + required_field_errors

    raise message.join("\n\n")
  end

  private def missing_field_error(columns, missing_field)
    message = "The table '#{@@table_name}' does not have a '#{missing_field[:name]}' column."
    best_match = Levenshtein::Finder.find missing_field[:name].to_s, columns.map(&.name), tolerance: 4

    if best_match
      message += " Did you mean #{best_match}?"
    else
      message += " Make sure you've added it to a migration."
    end
  end

  private def optional_field_error(field)
    <<-ERROR
    #{field[:name]} is marked as nilable (#{field[:name]} : #{field[:type]}?), but the database column does not allow nils.

    Try this...

      * Mark #{field[:name]} as non-nilable in your model: #{field[:name]} : #{field[:type]}
      * Or, change the column in a migration to allow nils: make_optional :users, :#{field[:name]}
    ERROR
  end

  private def required_field_error(field)
    <<-ERROR
    #{field[:name]} is marked as required (#{field[:name]} : #{field[:type]}), but the database column isn't.

    Try this...

      * Mark #{field[:name]} as nilable in your model: #{field[:name]} : #{field[:type]}?
      * Or, change the column in a migration to allow nils: make_optional :#{@@table_name}, :#{field[:name]}
    ERROR
  end
end
